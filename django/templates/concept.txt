Why need template
-------------------
Being a web framework, Django needs a convenient way to generate HTML dynamically. The most common approach relies on templates.

What is template
-------------------
A template contains the static parts of the desired HTML output as well as some special syntax describing how dynamic content will be inserted.

template engines
-------------------
A Django project can be configured with one or several template engines.
    Django template language (DTL)
    the popular alternative Jinja2


How to use template
-------------------
Django defines a standard API for loading and rendering templates regardless of the backend.
Loading:
    finding the template for a given identifier and preprocessing it, usually compiling it to an in-memory representation.
Rendering:
    interpolating the template with context data and returning the resulting string.


Configuration
-------------------
templates engines are configured with the TEMPLATES setting. It’s a list of configurations, one for each engine.
The default value is empty. The settings.py generated by the startproject command defines a more useful value:
    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [],
            'APP_DIRS': True,
            'OPTIONS': {
                # ... some options here ...
            },
        },
    ]


    DIRS defines a list of directories where the engine should look for template source files, in search order.
    APP_DIRS tells whether the engine should look for templates inside installed applications. Each backend defines a conventional name for the subdirectory inside applications where its templates should be stored.


Load template
-------------------
The django.template.loader module defines two functions to load templates.

get_template(template_name, using=None)
=======================================
    loads the template with the given name and returns a Template object.
    it will try each template engine in order until one succeeds. If the template cannot be found, it raises TemplateDoesNotExist. If the template is found but contains invalid syntax, it raises TemplateSyntaxError.
    If you want to restrict the search to a particular template engine, pass the engine’s NAME in the using argument.

select_template(template_name_list, using=None)
=======================================
    just like get_template(), except it takes a list of template names. It tries each name in order and returns the first template that exists.

2 exceptions
TemplateDoesNotExist
TemplateSyntaxError

rendering template
-------------------
Template objects returned by get_template() and select_template() must provide a render() method with the following signature:

Function:
Template.render(context=None, request=None)
    If context is provided, it must be a dict. If it isn’t provided, the engine will render the template with an empty context.
    If request is provided, it must be an HttpRequest. Then the engine must make it, as well as the CSRF token, available in the template. How this is achieved is up to each backend.


render_to_string(template_name, context=None, request=None, using=None)
    loads a template like get_template() and calls its render() method immediately

    Example:
        from django.template.loader import render_to_string
        rendered = render_to_string('my_template.html', {'foo': 'bar'})

Built-in backends
-------------------
class DjangoTemplates

When APP_DIRS is True, DjangoTemplates engines look for templates in the templates subdirectory of installed applications. This generic name was kept for backwards-compatibility.
